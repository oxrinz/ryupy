from __future__ import annotations
import ryupy.cuda
import typing
import ryupy

__all__ = [
    "Tensor"
]


class Tensor(ryupy._Tensor):
    def __add__(self, arg0: Tensor) -> Tensor: ...
    def __and__(self, arg0: Tensor) -> Tensor: ...
    def __eq__(self, arg0: Tensor) -> Tensor: ...
    def __ge__(self, arg0: Tensor) -> Tensor: ...
    def __gt__(self, arg0: Tensor) -> Tensor: ...
    def __iadd__(self, arg0: Tensor) -> Tensor: ...
    def __iand__(self, arg0: Tensor) -> Tensor: ...
    def __ilshift__(self, arg0: int) -> Tensor: ...
    def __imod__(self, arg0: Tensor) -> Tensor: ...
    def __imul__(self, arg0: Tensor) -> Tensor: ...
    def __init__(self, arg0: object) -> None: ...
    def __invert__(self) -> Tensor: ...
    def __ior__(self, arg0: Tensor) -> Tensor: ...
    def __ipow__(self, arg0: Tensor) -> Tensor: ...
    def __irshift__(self, arg0: int) -> Tensor: ...
    def __isub__(self, arg0: Tensor) -> Tensor: ...
    def __itruediv__(self, arg0: Tensor) -> Tensor: ...
    def __ixor__(self, arg0: Tensor) -> Tensor: ...
    def __le__(self, arg0: Tensor) -> Tensor: ...
    def __lshift__(self, arg0: int) -> Tensor: ...
    def __lt__(self, arg0: Tensor) -> Tensor: ...
    def __matmul__(self, arg0: Tensor) -> Tensor: ...
    def __mod__(self, arg0: Tensor) -> Tensor: ...
    def __mul__(self, arg0: Tensor) -> Tensor: ...
    def __ne__(self, arg0: Tensor) -> Tensor: ...
    def __or__(self, arg0: Tensor) -> Tensor: ...
    def __pow__(self, arg0: Tensor) -> Tensor: ...
    def __rshift__(self, arg0: int) -> Tensor: ...
    def __sub__(self, arg0: Tensor) -> Tensor: ...
    def __truediv__(self, arg0: Tensor) -> Tensor: ...
    def __xor__(self, arg0: Tensor) -> Tensor: ...
    @property
    def data(self) -> object:
        """
        :type: object
        """
    @property
    def flattenedData(self) -> object:
        """
        :type: object
        """
    @property
    def shape(self) -> list[int]:
        """
        :type: list[int]
        """
    __hash__ = None
    pass
