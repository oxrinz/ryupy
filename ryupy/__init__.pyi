from typing import List, Tuple, Union, Optional, overload
import numpy.typing as npt
import numpy as np
from enum import Enum
from typing import ClassVar

class Tensor:
    @overload
    def __init__(self, data: Union[npt.NDArray, List, Tuple]) -> None: ...
    
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def flattenedData(self) -> List[float]: ...
    @property
    def data(self) -> npt.NDArray[np.float32]: ...
    
    @property
    def grad(self) -> Optional['Tensor']: ...
    @grad.setter
    def grad(self, value: Optional['Tensor']) -> None: ...
    
    requires_grad: bool
    
    def backward(self) -> None: ...
    def __repr__(self) -> str: ...
    
    # Arithmetic operators
    def __add__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __sub__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __mul__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __truediv__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __mod__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    
    # In-place arithmetic operators
    def __iadd__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __isub__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __imul__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __itruediv__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __imod__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    
    # Power operators
    def __pow__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __ipow__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    
    # Comparison operators
    def __eq__(self, other: Union['Tensor', float]) -> 'Tensor': ...  # type: ignore
    def __ne__(self, other: Union['Tensor', float]) -> 'Tensor': ...  # type: ignore
    def __lt__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __le__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __gt__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    def __ge__(self, other: Union['Tensor', float]) -> 'Tensor': ...
    
    # Bitwise operators
    def __and__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    def __or__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    def __xor__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    def __invert__(self) -> 'Tensor': ...
    def __lshift__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    def __rshift__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    
    # In-place bitwise operators
    def __iand__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    def __ior__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    def __ixor__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    def __ilshift__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    def __irshift__(self, other: Union['Tensor', int]) -> 'Tensor': ...
    
    # Matrix multiplication
    def __matmul__(self, other: 'Tensor') -> 'Tensor': ...

# Module-level functions
def zeros(shape: Tuple[int, ...], *, grad: bool = False) -> Tensor: ...
def ones(shape: Tuple[int, ...], *, grad: bool = False) -> Tensor: ...
def fill(shape: Tuple[int, ...], value: float, *, grad: bool = False) -> Tensor: ...
def arange(start: float, stop: float, *, step: float = 1.0, grad: bool = False) -> Tensor: ...
def linspace(start: float, stop: float, num: int, *, grad: bool = False) -> Tensor: ...
def rand(shape: Tuple[int, ...], *, low: float = 0.0, high: float = 1.0, grad: bool = False) -> Tensor: ...
def randn(shape: Tuple[int, ...], *, mean: float = 0.0, std: float = 1.0, grad: bool = False) -> Tensor: ...

# Neural network submodule
class nn:
    class InitType(Enum):
        XAVIER_UNIFORM: ClassVar[InitType]
        XAVIER_NORMAL: ClassVar[InitType]
        KAIMING_UNIFORM: ClassVar[InitType]
        KAIMING_NORMAL: ClassVar[InitType]
    
    class Linear:
        weight: Tensor
        bias: Tensor
        
        def __init__(self, in_features: int, out_features: int, init_type: InitType) -> None: ...
        def forward(self, input: Tensor) -> Tensor: ...